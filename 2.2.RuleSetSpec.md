# Specification for the RuleSet contents

## **RuleSet**
RuleSet is the biggest envelope that contains a set of stages and meta information.
### Meta
:warning: (Under construction)
> types are all json serializable type
- `ruleset_id` (integer | string?): A unique value that identifies the connection. RuleSets in the path share the same `ruleset_id`.
- `owner_address` (string): An identifier of the owner of the RuleSet. Typically, this value could be IP address or host name of the repeaters.
- `num_stages` (integer): The number of stages that are contained in a RuleSet.
- ?`checksum` (string?): A value to validate there is no unexpected changes in the RuleSet.

### Body
- `stages` (list\[Stage\]): A set of Stages that are executed one by one from top to bottom.


## **Stage**
*Stage* is a set of Rules and the only one Rule in a Stage can be executed at one time.

### Meta
:warning: (Under construction)
- `stage_id` (integer): An index of stage to tell which stage is now operated.
- Anything else?
### Body
- `rules` (list\[Rule\]): A set of Rules that are evaluated and only one Rule is executed at one time.


### Constraints
:warning: (Under construction)

If there are multiple Rules whose condition is satisfied, only the first Rule is executed.

## **Rule**
*Rule* is a unit of execution that contains a set of conditions and corresponding actions.

### Meta
:warning: (Under construction)
- `rule_id` (integer): An index to identify Rules.
- `name` (string): Human readable name of the Rule for debugging
- `send_tag` (integer): Identify which Rule receives the message this Rule send
- `receive_tag` (integer): A tag to identify the message to be assigned to this Rule

### Body
- `condition` (Condition): A set of condition clauses to be met
- `action` (Action): A set of action clauses to be performed

> Do we need to make this `Condition` instread of `list[ConditionClause]`?   
> Do we have meta info for condition and action?
## **Condition**
A condition that contains a set of condition clauses
### Meta
- `name` (string): A name of this condition for debugging
- ?`num_clauses` (integer): The number of conditions to be met

### Body
- `condition_clauses` (list \[ConditionClause\]): A set of condition clauses to be evaluated.

## **Action**
An action that contains a set of action clauses
### Meta
- `name` (string): A name of this action for debugging
- ?`num_clauses` (integer): The number of actions to be met

### Body
- `action_clauses` (list\[ActionClause\]): A set of action clauses to be evaluated

## **ConditionClause**

### Meta
- `name` (string): A name of the instruction (e.g. `RES`, `NEW`)
<!-- - `partner_addresses` (string | null): A partner address if this condition needs to be  -->

### Body
- `arguments` (ConditionClauseArguments): Arguments to be provided to the instruction.
- `alias` (list\[string\]): If there are return values, from the condition clauses, these values are refered to with these names.
### Instruction Set
The following instructions are provided by Rule Engine or RuleSet Runtime as API functions to check the current status of the resources and devices.

:warning: (Under construction)
- `NEW`
- `RES`
- `ANC`
- `RECV`
- `TIMER`

**`NEW`**

Prepare for new resources that are not used in previous rules.
- Arguments
  - `resource_type` (string): The type of resources (e.g. "Bell", "GHZ")
  - `num_resource` (integer): The number of required resources
  - `partner_addresses` (list\[string\]): The list of target partner addresses
- Alias
  - `qubits` (list\[string\]): A list of identifiers 

- Note
  - qubit's names must be identical


Example: `NEW("Bell", 2, "198.168.0.2") -> ["qubit1", "qubit2"]`
```json
{
    // Instruction called `NEW`
    "name": "NEW",
    "arguments": {
        // Require two Bell pairs with a partner ("198.168.0.2")
        "resource_type": "Bell",
        "num_resource": 2,
        "partner_address": "198.168.0.2"
    },
    // These two Bell pairs are refered to as "qubit1" and "qubit2" respectively in the action
    "alias":{
        "qubits":[
            "qubit1",
            "qubit2"
        ]
    }
}
```
> Is `resource_type` good enough to represents various resources?  
> Are GHZ, Graph State can be thought as primitive?  
> Is `NEW` a good name?  

**`RES`**

Refer to the resources promoted in the previous stage.
- Arguments:
  - `labels` (list\[string\]): A set of alias names defined in the previous rules
- Alias
  - `qubits` (list\[string\]): A set of alias names to refer to the qubits in the action

Example: `RES(["qubit1", "qubit2", "qubit3"]) -> ["q1", "q2", "q3"]`
```json
{
    // Instructio name `RES`
    "name": "RES",
    "arguments":{
        // A set of qubit labels defined in previous stages
        "labels": [
            "qubit1",
            "qubit2",
            "qubit3",
        ]
    },
    // Ali
    "alias":{
        "qubits":[
            "q1",
            "q2",
            "q3",
        ]
    }
}
```
> Is this vaiolating scope?

**ANC**

Prepare for ancilla qubits 

**RECV**

Check if a message exists

**TIMER**

Check if a timer is expired or not

## **Action Clause**

:warning: (Under construction)

### Instruction Set
These instructions are provided by Rule Engine or RuleSet Runtime as API functions to manipulate resources, 
send messages and so on.

## ConditionClauseArguments
