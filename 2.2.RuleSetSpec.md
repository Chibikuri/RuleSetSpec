# Specification for the RuleSet contents

## **RuleSet**
RuleSet is the biggest envelope that contains a set of stages and meta information.
### Meta
:warning: (Under construction)
> types are all json serializable type
- `ruleset_id` (integer | string?): A unique value that identifies the connection. RuleSets in the path share the same `ruleset_id`.
- `owner_address` (string): An identifier of the owner of the RuleSet. Typically, this value could be IP address or host name of the repeaters.
- `num_stages` (integer): The number of stages that are contained in a RuleSet.
- ?`checksum` (string?): A value to validate there is no unexpected changes in the RuleSet.

### Body
- `stages` (list\[Stage\]): A set of Stages that are executed one by one from top to bottom.


## **Stage**
*Stage* is a set of Rules and the only one Rule in a Stage can be executed at one time.

### Meta
:warning: (Under construction)
- `stage_id` (integer): An index of stage to tell which stage is now operated.
- Anything else?
### Body
- `rules` (list\[Rule\]): A set of Rules that are evaluated and only one Rule is executed at one time.


### Constraints
:warning: (Under construction)

If there are multiple Rules whose condition is satisfied, only the first Rule is executed.

## **Rule**
*Rule* is a unit of execution that contains a set of conditions and corresponding actions.

### Meta
:warning: (Under construction)
- `rule_id` (integer): An index to identify Rules.
- `name` (string): Human readable name of the Rule for debugging
- `send_tag` (integer): Identify which Rule receives the message this Rule send
- `receive_tag` (integer): A tag to identify the message to be assigned to this Rule

### Body
- `condition` (Condition): A set of condition clauses to be met
- `action` (Action): A set of action clauses to be performed

> Do we need to make this `Condition` instread of `list[ConditionClause]`?   
> Do we have meta info for condition and action?
## **Condition**
A condition that contains a set of condition clauses
### Meta
- `name` (string): A name of this condition for debugging
- ?`num_clauses` (integer): The number of conditions to be met

### Body
- `condition_clauses` (list \[ConditionClause\]): A set of condition clauses to be evaluated.

## **Action**
An action that contains a set of action clauses
### Meta
- `name` (string): A name of this action for debugging
- ?`num_clauses` (integer): The number of actions to be met

### Body
- `action_clauses` (list\[ActionClause\]): A set of action clauses to be evaluated

## **ConditionClause**

### Meta
- `name` (string): A name of the instruction (e.g. `RES`, `NEW`)
<!-- - `partner_addresses` (string | null): A partner address if this condition needs to be  -->

### Body
- `arguments` (ConditionClauseArguments): Arguments to be provided to the instruction.
- `alias` (list\[string\]): If there are return values, from the condition clauses, these values are refered to with these names.
### Instruction Set
The following instructions are provided by Rule Engine or RuleSet Runtime as API functions to check the current status of the resources and devices.

:warning: (Under construction)
- `NEW`
- `RES`
- `ANC`
- `RECV`
- `TIMER`

**`NEW`**

Prepare for new resources that are not used in previous rules.
- Arguments
  - `resource_type` (string): The type of resources (e.g. "Bell", "GHZ")
  - `num_resource` (integer): The number of required resources
  - `partner_addresses` (list\[string\]): The list of target partner addresses
- Alias
  - `qubits` (list\[string\]): A list of identifiers 

- Note
  - qubit's names must be identical


Example: `NEW("Bell", 2, "198.168.0.2") -> ["qubit1", "qubit2"]`
```json
{
    // Instruction called `NEW`
    "name": "NEW",
    "arguments": {
        // Require two Bell pairs with a partner ("198.168.0.2")
        "resource_type": "Bell",
        "num_resource": 2,
        "partner_address": "198.168.0.2"
    },
    // These two Bell pairs are refered to as "qubit1" and "qubit2" respectively in the action
    "alias":{
        "qubits":[
            "qubit1",
            "qubit2"
        ]
    }
}
```
> Is `resource_type` good enough to represents various resources?  
> Are GHZ, Graph State can be thought as primitive?  
> Is `NEW` a good name?  

**`RES`**

Refer to the resources promoted in the previous stage.
- Arguments:
  - `resource_type`: a type of resource such as "Bell", "GHZ"
  - `num_resource` (integer): The number of required resources
  - `partner_addresses` (list\[string\]): The list of target partner addresses
- Alias
  - `qubits` (list\[string\]): A set of alias names to refer to the qubits in the action

Example: `RES("GHZ", 3, "0.0.0.0") -> ["q1", "q2", "q3"]`
```json
{
    // Instructio name `RES`
    "name": "RES",
    "arguments":{
        "resource_type": "GHZ",
        "num_resource": 3,
        "partner_address": "0.0.0.0"
    },
    "alias":{
        "qubits":[
            "q1",
            "q2",
            "q3",
        ]
    }
}
```

**ANC**

Prepare for ancilla qubits for logical qubits

- Arguments:
  - `num_resource` (integer): The number of required ancilla qubits
- Alias
  - `qubits` (list \[string\]): A set of alias names to refer to the qubits in the action

Example: `ANC(3) -> ["q1", "q2", "q3"]`
```json
{
    "name": "ANC",
    "arguments": {
        "num_resource": 4
    },
    "alias":{
        "qubits": [
            "q1",
            "q2",
            "q3"
        ]
    }
}
```


**RECV**

Check if a message exists and take the message if it exists.
The `receive_tag` defined in meta information of Rule is used here. :question:

- Arguments:
  - `source_address` (string): A partner address that sends a message to this repeater.
- Alias
  - `message` (string): An identifier to manipulate the received message

Example `RECV("192.168.0.1") -> "msg"`
```json
{
    "name": "RECV",
    "arguments": {
        "source_address": "192.168.0.1"
    },
    "alias": {
        "message": "msg"
    }
}
```

> Is the `receive_tag` used here?  
> This is similar to the current Wait clause, but possible to specify which message

**TIMER**

Check if a timer is expired or not

- Arguments:
  - `timer_id` (string): An identifier for the timer :question:
- Alias
  - None

Example `TIMER("timer1")`
```json
{
    "name": "TIMER",
    "arguments": {
        "timer_id": "timer1"
    },
    "alias": {}
}
```

> Which layer keep the timer? RuleEngine? If the timer expires but still executing prvious rules what happen?

## **Action Clause**

:warning: (Under construction)

### Instruction Set
These instructions are provided by Rule Engine or RuleSet Runtime as API functions to manipulate resources, 
send messages and so on.

## ConditionClauseArguments
